;;; al-autoload.el --- Additional functionality to autoload Emacs packages  -*- lexical-binding: t -*-

;; Copyright © 2013–2025 Alex Kost

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(require 'al-file)

(defvar al/autoloads-regexp
  (rx "-autoloads.el" string-end)
  "Regexp to match Emacs `autoloads' file.")

(defvar al/ignored-package-autoloads
  '("magit"  ; too verbose (≈ 2500 lines for "autoloads.el"?!!)
    "auctex" ; cointains (require 'tex-site)
    ;; Geiser implementations have the following line in their
    ;; autoloads: (geiser-activate-implementation '<impl>).
    ;; `geiser-activate-implementation' is defined
    ;; "geiser-autoloads.el", so if implementations autoloads are loaded
    ;; before geiser ones, that line will fail.
    "geiser-[a-z]")
  "Autoloads that will be ignored by `al/concat-autoloads'.
This is a list of regexps to match package directories.")

(defmacro al/autoload (file &rest symbols)
  "Autoload (unquoted) SYMBOLS from file as interactive commands."
  (declare (indent 1))
  `(progn
     ,@(mapcar (lambda (symbol)
                 `(autoload ',symbol ,file nil t))
               symbols)))

(defun al/autoloads-file (directory)
  "Return the name of `autoloads' file for DIRECTORY."
  (let* ((dir  (expand-file-name directory))
         (base (file-name-nondirectory (directory-file-name dir))))
    (expand-file-name (concat base "-autoloads.el") dir)))

(defun al/find-autoloads (directory)
  "Return a list of Emacs `autoloads' files in DIRECTORY."
  (car (directory-files
        directory 'full-name al/autoloads-regexp 'no-sort 1)))

(defun al/concat-autoloads (directory output-file &optional add-to-path)
  ;; Some code is taken from `package-quickstart-refresh'.
  "Put the contents of DIRECTORY subdirs `autoloads' files into OUTPUT-FILE.
Refresh OUTPUT-FILE i.e., remove its previous contents.
If ADD-TO-PATH is non-nil, add subdirs to `load-path' in OUTPUT-FILE.
ADD-TO-PATH should be nil, `append' or `prepend'."
  (let ((info-dirs nil)
        (load-dirs nil))
    (with-temp-file output-file
      (emacs-lisp-mode)         ; for `syntax-ppss'
      (insert ";;; Autoloads for sub-directories of "
              directory "  -*- lexical-binding: t -*-\n\n"
              ";; This file is generated by `al/concat-autoloads', "
              (format-time-string "%e %B %Y %T" (current-time))
              ".\n")
      (dolist (dir (al/subdirs directory))
        (let* ((elisp-dir (or (al/file-if-exists
                               (expand-file-name "elisp" dir))
                              dir))
               (doc-dir   (or (al/file-if-exists
                               (expand-file-name "doc" dir))
                              dir)))
          (when add-to-path
            (push elisp-dir load-dirs))
          (when (file-exists-p (expand-file-name "dir" doc-dir))
            (push doc-dir info-dirs))
          (if (seq-find (lambda (pkg)
                          (string-match-p pkg elisp-dir))
                        al/ignored-package-autoloads)
              (message "Ignoring autoloads for %s" elisp-dir)
            (let ((file (al/find-autoloads elisp-dir)))
              (when file
                (insert-file-contents file)
                ;; Remove comments.
                (while (re-search-forward "^;.*\n" nil 'move)
                  (unless (ppss-string-terminator
                           (save-match-data (syntax-ppss)))
                    (replace-match "")))
                (insert "\n"))))))
      (when (and add-to-path load-dirs)
        (pp `(setq load-path
                   ,(if (eq 'prepend add-to-path)
                        `(append load-path ',load-dirs)
                      `(append ',load-dirs load-path)))
            (current-buffer)))
      (when info-dirs
        (pp `(with-eval-after-load 'info
               (info-initialize)
               (setq Info-directory-list
                     (append ',info-dirs Info-directory-list)))
            (current-buffer))))))

(defun al/update-autoloads (&rest dirs)
  "Update the contents of `autoloads' files for all DIRS."
  (require 'loaddefs-gen)
  (dolist (dir dirs)
    (loaddefs-generate dir (al/autoloads-file dir))))

(provide 'al-autoload)

;;; al-autoload.el ends here
