;;; al-autoloads-make.el --- Additional functionality to create autoloads for Emacs packages  -*- lexical-binding: t -*-

;; Copyright © 2013–2025 Alex Kost

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This file is separated from "al-autoload.el" because it requires
;; `loaddefs-gen', and since `al-autoload' is loaded on every Emacs
;; start, I don't want to increase my initial start time.

;;; Code:

(eval-when-compile (require 'cl-lib))
(require 'loaddefs-gen)
(require 'al-autoload)
(require 'al-file)

(defvar al/ignored-package-autoloads
  '("magit"  ; too verbose (≈ 2500 lines for "autoloads.el"?!!)
    "auctex" ; cointains (require 'tex-site)
    ;; Geiser implementations have the following line in their
    ;; autoloads: (geiser-activate-implementation '<impl>).
    ;; `geiser-activate-implementation' is defined
    ;; "geiser-autoloads.el", so if implementations autoloads are loaded
    ;; before geiser ones, that line will fail.
    "geiser-[a-z]")
  "Autoloads that will be ignored by `al/generate-autoloads'.
This is a list of regexps to match package directories.")

(cl-defun al/generate-autoloads (directory &key output-file add-to-path subdirs)
  "Generate OUTPUT-FILE with autoloads for DIRECTORY.

Refresh OUTPUT-FILE i.e., remove its previous contents.

If ADD-TO-PATH is non-nil, add subdirs to `load-path' in OUTPUT-FILE.
ADD-TO-PATH should be nil, `append' or `prepend'.

SUBDIRS can have one of the following values:
  - nil:    use only DIRECTORY;
  - t:      use both DIRECTORY and its sub-directories;
  - `only': use sub-directories but not DIRECTORY itself."
  (let* ((dirs (and subdirs (al/subdirs directory)))
         (dirs (if (eq 'only subdirs)
                   dirs
                 (cons (file-truename directory) dirs)))
         (auto-dirs '())
         (load-dirs '())
         (info-dirs '()))
    (dolist (dir dirs)
      (let* ((elisp-dir (or (al/file-if-exists
                             (expand-file-name "elisp" dir))
                            dir))
             (doc-dir   (or (al/file-if-exists
                             (expand-file-name "doc" dir))
                            dir))
             (dir-name (file-name-nondirectory
                        (directory-file-name dir))))
        (when add-to-path
          (push elisp-dir load-dirs))
        (cond ((file-exists-p (expand-file-name "dir" doc-dir))
               (push doc-dir info-dirs))
              ((file-exists-p (expand-file-name "dir" dir))
               (push dir info-dirs)))
        (if (seq-find (lambda (pkg)
                        (string-match-p pkg dir-name))
                      al/ignored-package-autoloads)
            (message "Ignoring %s" dir)
          (push elisp-dir auto-dirs))))
    (let ((extra-data
           (with-temp-buffer
             (insert ";; Autoloads for "
                     (cl-case subdirs
                       ((nil) directory)
                       ((only) (concat "sub-directories of " directory))
                       ((t) (concat directory " and its sub-directories."))
                       (t "!! Unknown SUBDIRS value !!"))
                     "\n"
                     ";; This file was generated by `al/generate-autoloads', "
                     (format-time-string "%e %B %Y %T" (current-time))
                     ".\n\n")
             (when (and add-to-path load-dirs)
               (pp `(setq load-path
                          ,(if (eq 'prepend add-to-path)
                               `(append ',load-dirs load-path)
                             `(append load-path ',load-dirs)))
                   (current-buffer))
               (insert "\n"))
             (when info-dirs
               (pp `(with-eval-after-load 'info
                      (info-initialize)
                      (setq Info-directory-list
                            (append ',info-dirs Info-directory-list)))
                   (current-buffer)))
             (buffer-substring-no-properties (point-min) (point-max)))))
      ;; `loaddefs-generate' makes the following lines in the generated
      ;; autoloads file: (autoload 'foo-bar "../packages/foo/foo" "..." t).
      ;; Clearly, we need this instead: (autoload 'foo-bar "foo" "..." t).
      ;; To make it possible, we temporarily change
      ;; `loaddefs-generate--file-load-name'.
      (cl-letf (((symbol-function 'loaddefs-generate--file-load-name)
                 (lambda (file &rest _) (file-name-base file))))
        (loaddefs-generate auto-dirs
                           (or output-file (al/autoloads-file directory))
                           nil extra-data nil t)))))

(provide 'al-autoloads-make)

;;; al-autoloads-make.el ends here
